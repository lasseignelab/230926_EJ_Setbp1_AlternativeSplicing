---
title: "Explore SJ usage by cell type"
author: "Emma Jones"
date: "2024-03-07"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

The purpose of this script is to visualize the splice junction usage across cell types. It is dependent on running all seurat scripts, and marvel scripts 01 through 04. Please use docker image setbp1_alternative_splicing:1.0.7. THIS SCRIPT IS NOW ARCHIVED.

## Load packages

```{r load packages}
suppressPackageStartupMessages({
  # Load Lasseigne Lab standard packages
  library(here)
  library(styler)
  library(lintr)
  library(tidyverse)
  library(patchwork)
  library(ComplexHeatmap)
  library(viridis)

  # Load MARVEL package
  library(MARVEL)

  # Load adjunct MARVEL packages
  library(ggnewscale)
  library(ggrepel)
  library(reshape2)
  library(plyr)
  library(stringr)
  library(textclean)
  library(AnnotationDbi)
  library(clusterProfiler)
  library(org.Hs.eg.db)
  library(org.Mm.eg.db)
  library(gtools)
  library(GenomicRanges)
  library(IRanges)
  library(S4Vectors)
  library(wiggleplotr)
  library(Matrix)
  library(data.table)
  library(gridExtra)
  library(ggridges)
  library(GenomicFeatures)
  library(rtracklayer)
  library(ggpmisc)
})

# set seed
set.seed(123)

# source functions
source(here::here("src", "marvel", "functions.R"))
```

## Set colors

```{r set colors}
cell_type_colors <- c(
  `Astrocytes` = "#6CA9E2",
  `Excitatory Neurons` = "#98D070",
  `Inhibitory Neurons` = "#DEE971",
  `Microglia` = "#B898E4",
  `Oligodendrocytes` = "#4AD8E6",
  `OPCs` = "#0A9A8D",
  `Vascular Cells` = "#E28C67"
)

condition_colors <- c(
  `mutant` = "#D8D8D8",
  `wildtype` = "#9E9E9E"
)
```

## Load data

First, we need to load in the splice junction usage data from script 04

```{r load in data}
# Load MARVEL data from marvel 04
load(here::here("data", "marvel", "marvel_04_split_counts.Rdata"))

# load in sj usage split by cell type
sj_usage_cell_type <- readRDS(here::here(
  "data", "marvel",
  "sj_usage_cell_type.rds"
))

# load in sj usage split by cell type and condition
sj_usage_condition <- readRDS(here::here(
  "data", "marvel",
  "sj_usage_condition.rds"
))
```

### Adjust data formatiing

Also, we need to adjust some of the formatting for this data.

```{r fix sj_usage_condition}
mutant_sju <- sj_usage_condition[1, ]
mutant_sju <- do.call(cbind, mutant_sju)
colnames(mutant_sju) <- names(cell_group_list)

wt_sju <- sj_usage_condition[2, ]
wt_sju <- do.call(cbind, wt_sju)
colnames(wt_sju) <- names(cell_group_list)
```

reformat cell type level data for visualization

```{r reformat cell type level data for visualization}
colnames(sj_usage_cell_type) <- names(cell_type_colors)

sj_usage_cell_type <- as.data.frame(sj_usage_cell_type)
sj_usage_cell_type$sj_position <- rownames(sj_usage_cell_type)
rownames(sj_usage_cell_type) <- NULL

sj_usage_cell_type <- pivot_longer(sj_usage_cell_type,
  cols = colnames(sj_usage_cell_type)[1:7], names_to = "cell_type",
  values_to = "sj_usage"
)

sj_usage_cell_type$sj_usage[is.infinite(sj_usage_cell_type$sj_usage)] <- NaN
sj_usage_cell_type$sj_usage[sj_usage_cell_type$sj_usage > 100] <- 100
```

### Visualize sj usage

```{r visualize sj usage}
# make df with dropped zeroes
sj_usage_cell_type_drop0 <- sj_usage_cell_type

sj_usage_cell_type_drop0$sj_usage[sj_usage_cell_type_drop0$sj_usage == 0] <- NaN

sj_usage_cell_type_ridge <-
  ggplot(sj_usage_cell_type_drop0, aes(
    x = log(sj_usage), y = cell_type,
    fill = cell_type, color = cell_type,
    alpha = 0.5
  )) +
  geom_density_ridges(show.legend = FALSE) +
  theme_minimal(base_size = 15) +
  theme(
    axis.title = element_text(face = "bold"),
    axis.text = element_text(face = "bold", color = "black"),
    legend.text = element_text(face = "bold", size = 12),
    axis.text.x = element_text()
  ) +
  scale_fill_manual(values = cell_type_colors) +
  scale_color_manual(values = cell_type_colors) +
  xlab("Log (Splice Junction Usage)") +
  ylab("Cell Type")

sj_usage_cell_type_ridge
```

```{r save plot}
# save
png(here::here("results", "marvel_outputs", "nonzero_SJ_usage_cell_types.png"),
  width = 8, height = 6, units = "in", res = 300
)
sj_usage_cell_type_ridge
dev.off()
```

### Condition (mutant vs wt) reformatting

```{r reformat mutant level data for visualization}
mutant_sju <- as.data.frame(mutant_sju)
mutant_sju$sj_position <- rownames(mutant_sju)
rownames(mutant_sju) <- NULL
mutant_sju$condition <- "Mutant"

mutant_sju <- pivot_longer(mutant_sju,
  cols = colnames(mutant_sju)[1:7], names_to = "cell_type",
  values_to = "sj_usage"
)

mutant_sju$sj_usage[is.infinite(mutant_sju$sj_usage)] <- NaN
mutant_sju$sj_usage[mutant_sju$sj_usage > 100] <- 100
```


```{r reformat wt level data for visualization}
wt_sju <- as.data.frame(wt_sju)
wt_sju$sj_position <- rownames(wt_sju)
rownames(wt_sju) <- NULL
wt_sju$condition <- "Wildtype"

wt_sju <- pivot_longer(wt_sju,
  cols = colnames(wt_sju)[1:7], names_to = "cell_type",
  values_to = "sj_usage"
)

wt_sju$sj_usage[is.infinite(wt_sju$sj_usage)] <- NaN
wt_sju$sj_usage[wt_sju$sj_usage > 100] <- 100

# r bind together both conditions
conditions_sju <- rbind(mutant_sju, wt_sju)
```

## Visualize SJ usage distirubutions split by cell type and condition

```{r visualize sj usage}
# make df with dropped zeroes
conditions_sju_drop0 <- conditions_sju

conditions_sju_drop0$sj_usage[conditions_sju_drop0$sj_usage == 0] <- NaN

sj_usage_condition_ridge <-
  ggplot(conditions_sju_drop0, aes(
    x = log(sj_usage), y = cell_type,
    fill = cell_type, color = cell_type,
    alpha = condition
  )) +
  geom_density_ridges() +
  theme_minimal(base_size = 15) +
  theme(
    axis.title = element_text(face = "bold"),
    axis.text = element_text(face = "bold", color = "black"),
    legend.text = element_text(face = "bold", size = 12),
    axis.text.x = element_text()
  ) +
  scale_fill_manual(values = cell_type_colors) +
  scale_alpha_manual(values = c(0.2, 0.6)) +
  scale_color_manual(values = cell_type_colors) +
  xlab("Log (Splice Junction Usage)") +
  ylab("Cell Type")

sj_usage_condition_ridge
```

```{r save plot}
# save
png(here::here("results", "marvel_outputs", "nonzero_SJ_usage_conditions.png"),
  width = 8, height = 6, units = "in", res = 300
)
sj_usage_condition_ridge
dev.off()
```

## Count splice junctions for each gene

Now, we want to count the splice junctions detected for each gene. I also am curious at what is driving this number, so I will look at the relationships between median expression and gene length.

```{r count splice junctions}
# Get all expressed gene names
all_expressed_genes <- rownames(gene_counts)[rowSums(gene_counts) > 0]
```

```{r count sjs per cell type}
# Make NA matrix, with 7 columns for cell types
sj_per_gene <- matrix(NA, nrow = length(all_expressed_genes), ncol = 7)
# Add rownames
rownames(sj_per_gene) <- sort(all_expressed_genes)

# Initialize column
column <- 0

# Add in each table - these numbers are to exclude the functions
for (i in split_matrices_list) {
  column <- column + 1
  table <- get_sjs_per_gene(i)
  indices <- match(rownames(sj_per_gene), names(table))
  sj_per_gene[, column] <- ifelse(!is.na(indices), table[indices], 0)
}

# Add colnames
colnames(sj_per_gene) <-
  names(split_matrices_list)
```

Now save!

```{r save sjs per gene}
write.csv(sj_per_gene, here::here("results", "tables", "sj_per_gene.csv"))
```

I want to visualize a dot plot and color by cell type, I think I need to pivot longer and make a column called cell type.

```{r pivot dataframe}
sj_per_gene <- as.data.frame(sj_per_gene)
sj_per_gene$gene_name <- rownames(sj_per_gene)
rownames(sj_per_gene) <- NULL

sj_per_gene <- pivot_longer(sj_per_gene,
  cols = colnames(sj_per_gene)[1:7], names_to = "cell_type",
  values_to = "num_sjs"
)
```

To plot with median expression in a cell type, we need to get the median expression of each gene for each cell type.

```{r make df for median expression}
median_gene_expr <- data.frame(matrix(ncol = 7, nrow = nrow(gene_counts)))
colnames(median_gene_expr) <- names(cell_group_list)
rownames(median_gene_expr) <- rownames(gene_counts)
```

```{r get normalized data split by cell type}
split_norm_list <- lapply(names(cell_group_list), function(x) {
  subset_cell_type_matrices(
    gene_matrix = setbp1_marvel[["gene.norm.matrix"]],
    cell_type = x
  )
})

names(split_norm_list) <- names(cell_group_list)

# use the normalized gene expression data
for (type in names(cell_group_list)) {
  median_gene_expr[, type] <-
    rowMedians(as.matrix(split_norm_list[[type]][["Gene Counts"]]))
}

# move rownames
median_gene_expr$gene_name <- rownames(median_gene_expr)
rownames(median_gene_expr) <- NULL

# pivot longer
median_gene_expr <- pivot_longer(median_gene_expr,
  cols = colnames(median_gene_expr)[1:7], names_to = "cell_type",
  values_to = "median_expr"
)

# combine with number of sjs
sj_per_gene <- left_join(sj_per_gene, median_gene_expr,
  by = c(
    "gene_name" = "gene_name",
    "cell_type" = "cell_type"
  )
)
```

## Plot!!!

```{r make scatterplot}
smooth_sj_per_gene <- ggplot(sj_per_gene, aes(
  x = median_expr, y = num_sjs,
  color = cell_type, fill = cell_type
)) +
  stat_poly_line() +
  stat_poly_eq(use_label(c("eq", "P"))) +
  scale_fill_manual(values = cell_type_colors) +
  scale_color_manual(values = cell_type_colors) +
  theme_minimal(base_size = 15) +
  theme(
    axis.title = element_text(face = "bold"),
    axis.text = element_text(face = "bold", color = "black"),
    legend.text = element_text(face = "bold", size = 12),
    legend.title = element_text(face = "bold"),
    axis.text.x = element_text()
  ) +
  guides(
    color = guide_legend(title = "Cell Type"),
    fill = guide_legend(title = "Cell Type")
  ) +
  xlab("Median Gene Expression") +
  ylab("Number of Splice Junctions")

smooth_sj_per_gene
```

```{r save plot}
# save
png(here::here("results", "marvel_outputs", "smooth_sj_per_gene.png"),
  width = 8, height = 6, units = "in", res = 300
)
smooth_sj_per_gene
dev.off()

```

```{r facet wrap}
# use facet wrap and geom_scatter to split out each cell type
supps_sj_per_gene <- ggplot(sj_per_gene, aes(
  x = median_expr, y = num_sjs,
  color = cell_type, fill = cell_type
)) +
  geom_point(alpha = 0.5) +
  facet_wrap(~cell_type) +
  stat_poly_line() +
  stat_poly_eq(use_label(c("eq", "P"))) +
  scale_fill_manual(values = cell_type_colors) +
  scale_color_manual(values = cell_type_colors) +
  theme_minimal(base_size = 15) +
  theme(
    axis.title = element_text(face = "bold"),
    axis.text = element_text(face = "bold", color = "black"),
    legend.text = element_text(face = "bold", size = 12),
    legend.title = element_text(face = "bold"),
    axis.text.x = element_text()
  ) +
  guides(
    color = guide_legend(title = "Cell Type"),
    fill = guide_legend(title = "Cell Type")
  ) +
  xlab("Median Gene Expression") +
  ylab("Number of Splice Junctions")

supps_sj_per_gene
```

```{r save plot}
# save
png(here::here("results", "marvel_outputs", "supps_sj_per_gene.png"),
  width = 12, height = 10, units = "in", res = 300
)
supps_sj_per_gene
dev.off()
```

## How does gene length influence number of splice junctions?

```{r get gene length}
# genome directory
genome_dir <- "/data/project/lasseigne_lab/GENOME_dir/GENCODE_mm39/release_M31/"

# load GTF
m31_gtf <-
  import(paste0(genome_dir, "GTF/gencode.vM31.primary_assembly.annotation.gtf"))

# get lengths for all attributes
gene_lengths <- width(m31_gtf)

# get types
types <- m31_gtf@elementMetadata@listData[["type"]]

# pull gene names
gene_names <- m31_gtf@elementMetadata@listData[["gene_name"]]

# add gene names to lengths
gene_lengths <- cbind(gene_names, gene_lengths)

# pull only full genes
gene_lengths <- gene_lengths[types == "gene", ]

# make df
gene_lengths <- as.data.frame(gene_lengths)

# keep only genes in count matrix
gene_counts <- setbp1_marvel[["gene.count.matrix"]]
to_keep <- rownames(gene_counts)
gene_lengths <- gene_lengths[gene_lengths$gene_names %in% to_keep, ]

# pull out duplicates
duplicated <- gene_lengths$gene_names[duplicated(gene_lengths$gene_names)]
duplicated_lengths <- gene_lengths[gene_lengths$gene_names %in% duplicated, ]
# get max values for length
max_values <- duplicated_lengths %>%
  group_by(gene_names) %>%
  filter(gene_lengths == max(gene_lengths)) %>%
  arrange(gene_names, gene_lengths)

# remove all duplicates
gene_lengths <- gene_lengths[!gene_lengths$gene_names %in% duplicated, ]
# add back max duplicates
gene_lengths <- rbind(gene_lengths, max_values)

colnames(gene_lengths) <- c("gene_name", "gene_length")
```


```{r plot gene lengths and number of sjs}
sjs_lengths <- left_join(sj_per_gene, gene_lengths)

sjs_lengths$gene_length <- as.numeric(sjs_lengths$gene_length)
```

## Plot!!!

```{r make scatterplot}
smooth_sjs_lengths <- ggplot(sjs_lengths, aes(
  x = gene_length, y = num_sjs,
  color = cell_type, fill = cell_type
)) +
  stat_poly_line() +
  stat_poly_eq(use_label(c("eq", "P"))) +
  scale_fill_manual(values = cell_type_colors) +
  scale_color_manual(values = cell_type_colors) +
  theme_minimal(base_size = 15) +
  theme(
    axis.title = element_text(face = "bold"),
    axis.text = element_text(face = "bold", color = "black"),
    legend.text = element_text(face = "bold", size = 12),
    legend.title = element_text(face = "bold"),
    axis.text.x = element_text()
  ) +
  guides(
    color = guide_legend(title = "Cell Type"),
    fill = guide_legend(title = "Cell Type")
  ) +
  xlab("Gene Length") +
  ylab("Number of Splice Junctions")

smooth_sjs_lengths
```

```{r save plot}
# save
png(here::here("results", "marvel_outputs", "smooth_sjs_lengths.png"),
  width = 8, height = 6, units = "in", res = 300
)
smooth_sjs_lengths
dev.off()

```

```{r facet wrap}
# use facet wrap and geom_point to split out each cell type
supps_sjs_lengths <- ggplot(sjs_lengths, aes(
  x = gene_length, y = num_sjs,
  color = cell_type, fill = cell_type
)) +
  geom_point(alpha = 0.5) +
  facet_wrap(~cell_type) +
  stat_poly_line() +
  stat_poly_eq(use_label(c("eq", "P"))) +
  scale_fill_manual(values = cell_type_colors) +
  scale_color_manual(values = cell_type_colors) +
  theme_minimal(base_size = 15) +
  theme(
    axis.title = element_text(face = "bold"),
    axis.text = element_text(face = "bold", color = "black"),
    legend.text = element_text(face = "bold", size = 12),
    legend.title = element_text(face = "bold"),
    axis.text.x = element_text()
  ) +
  guides(
    color = guide_legend(title = "Cell Type"),
    fill = guide_legend(title = "Cell Type")
  ) +
  xlab("Gene Length") +
  ylab("Number of Splice Junctions")

supps_sjs_lengths

# save
png(here::here("results", "marvel_outputs", "supps_sjs_lengths.png"),
  width = 12, height = 10, units = "in", res = 300
)
supps_sjs_lengths
dev.off()
```



#### Style

```{r tidy script}
style_file("explore_sj_usage.Rmd")

lint("explore_sj_usage.Rmd",
  linters = linters_with_defaults(
    object_length_linter = NULL,
    object_name_linter = NULL,
    object_usage_linter = NULL
  )
)
```

#### Software versions

My software versions will be commented below.

```{r versions}
sessionInfo()
```
R version 4.3.1 (2023-06-16)
Platform: x86_64-pc-linux-gnu (64-bit)
Running under: Ubuntu 22.04.3 LTS

Matrix products: default
BLAS:   /usr/lib/x86_64-linux-gnu/openblas-pthread/libblas.so.3 
LAPACK: /usr/lib/x86_64-linux-gnu/openblas-pthread/libopenblasp-r0.3.20.so;  LAPACK version 3.10.0

locale:
 [1] LC_CTYPE=en_US.UTF-8       LC_NUMERIC=C               LC_TIME=en_US.UTF-8       
 [4] LC_COLLATE=en_US.UTF-8     LC_MONETARY=en_US.UTF-8    LC_MESSAGES=en_US.UTF-8   
 [7] LC_PAPER=en_US.UTF-8       LC_NAME=C                  LC_ADDRESS=C              
[10] LC_TELEPHONE=C             LC_MEASUREMENT=en_US.UTF-8 LC_IDENTIFICATION=C       

time zone: Etc/UTC
tzcode source: system (glibc)

attached base packages:
[1] stats4    grid      stats     graphics  grDevices utils     datasets  methods  
[9] base     

other attached packages:
 [1] ggridges_0.5.4        gridExtra_2.3         data.table_1.14.8    
 [4] Matrix_1.6-1.1        wiggleplotr_1.24.0    GenomicRanges_1.52.1 
 [7] GenomeInfoDb_1.36.4   gtools_3.9.4          org.Mm.eg.db_3.17.0  
[10] org.Hs.eg.db_3.17.0   clusterProfiler_4.8.3 AnnotationDbi_1.62.2 
[13] IRanges_2.34.1        S4Vectors_0.38.2      Biobase_2.60.0       
[16] BiocGenerics_0.46.0   textclean_0.9.3       plyr_1.8.9           
[19] reshape2_1.4.4        ggrepel_0.9.4         ggnewscale_0.4.9     
[22] MARVEL_2.0.5          viridis_0.6.4         viridisLite_0.4.2    
[25] ComplexHeatmap_2.16.0 patchwork_1.1.3       lubridate_1.9.3      
[28] forcats_1.0.0         stringr_1.5.1         dplyr_1.1.3          
[31] purrr_1.0.2           readr_2.1.4           tidyr_1.3.0          
[34] tibble_3.2.1          ggplot2_3.4.4         tidyverse_2.0.0      
[37] lintr_3.1.0           styler_1.10.2         here_1.0.1           

loaded via a namespace (and not attached):
  [1] RColorBrewer_1.1-3      jsonlite_1.8.7          rstudioapi_0.15.0      
  [4] shape_1.4.6             magrittr_2.0.3          farver_2.1.1           
  [7] rmarkdown_2.25          fs_1.6.3                GlobalOptions_0.1.2    
 [10] zlibbioc_1.46.0         vctrs_0.6.4             memoise_2.0.1          
 [13] RCurl_1.98-1.12         ggtree_3.8.2            htmltools_0.5.6.1      
 [16] qdapRegex_0.7.8         gridGraphics_0.5-1      desc_1.4.2             
 [19] cachem_1.0.8            igraph_1.5.1            lifecycle_1.0.4        
 [22] iterators_1.0.14        pkgconfig_2.0.3         gson_0.1.0             
 [25] R6_2.5.1                fastmap_1.1.1           GenomeInfoDbData_1.2.10
 [28] clue_0.3-65             aplot_0.2.2             digest_0.6.33          
 [31] enrichplot_1.20.3       colorspace_2.1-0        ps_1.7.5               
 [34] rprojroot_2.0.3         RSQLite_2.3.1           fansi_1.0.5            
 [37] timechange_0.2.0        polyclip_1.10-6         httr_1.4.7             
 [40] compiler_4.3.1          remotes_2.4.2.1         bit64_4.0.5            
 [43] withr_2.5.2             doParallel_1.0.17       downloader_0.4         
 [46] backports_1.4.1         BiocParallel_1.34.2     DBI_1.1.3              
 [49] ggforce_0.4.1           R.utils_2.12.2          MASS_7.3-60            
 [52] rjson_0.2.21            HDO.db_0.99.1           tools_4.3.1            
 [55] scatterpie_0.2.1        ape_5.7-1               R.oo_1.25.0            
 [58] glue_1.6.2              callr_3.7.3             nlme_3.1-163           
 [61] R.cache_0.16.0          GOSemSim_2.26.1         shadowtext_0.1.2       
 [64] cluster_2.1.4           fgsea_1.26.0            generics_0.1.3         
 [67] gtable_0.3.4            tzdb_0.4.0              R.methodsS3_1.8.2      
 [70] hms_1.1.3               tidygraph_1.2.3         xml2_1.3.5             
 [73] utf8_1.2.4              XVector_0.40.0          foreach_1.5.2          
 [76] pillar_1.9.0            yulab.utils_0.1.0       circlize_0.4.15        
 [79] splines_4.3.1           tweenr_2.0.2            treeio_1.24.3          
 [82] lattice_0.21-8          bit_4.0.5               tidyselect_1.2.0       
 [85] GO.db_3.17.0            Biostrings_2.68.1       knitr_1.44             
 [88] xfun_0.40               graphlayouts_1.0.1      matrixStats_1.0.0      
 [91] rex_1.2.1               stringi_1.8.1           ggfun_0.1.3            
 [94] lazyeval_0.2.2          yaml_2.3.7              evaluate_0.22          
 [97] codetools_0.2-19        ggraph_2.1.0            qvalue_2.32.0          
[100] ggplotify_0.1.2         cli_3.6.1               munsell_0.5.0          
[103] processx_3.8.2          Rcpp_1.0.11             png_0.1-8              
[106] parallel_4.3.1          blob_1.2.4              DOSE_3.26.2            
[109] bitops_1.0-7            tidytree_0.4.5          cyclocomp_1.1.1        
[112] scales_1.2.1            crayon_1.5.2            GetoptLong_1.0.5       
[115] rlang_1.1.2             cowplot_1.1.1           fastmatch_1.1-4        
[118] KEGGREST_1.40.1    
