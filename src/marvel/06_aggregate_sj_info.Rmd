---
title: "Aggregate Splice Junction Information"
author: "Emma Jones"
date: "2024-02-19"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

## Aggregate Splice Junction Information

The purpose of this script is to aggregate sj and expression information by cell type in a meaningful way. It is dependent on all seurat and marvel scripts 01-05. Please run in docker 1.0.6.

## Load Packages

```{r load packages}
suppressPackageStartupMessages({
  # Load Lasseigne Lab standard packages
  library(here)
  library(styler)
  library(lintr)
  library(tidyverse)
  library(patchwork)
  library(ComplexHeatmap)
  library(viridis)
  library(factoextra)

  # Load MARVEL package
  library(MARVEL)

  # Load adjunct MARVEL packages
  library(ggnewscale)
  library(ggrepel)
  library(reshape2)
  library(plyr)
  library(stringr)
  library(textclean)
  library(AnnotationDbi)
  library(clusterProfiler)
  library(org.Hs.eg.db)
  library(org.Mm.eg.db)
  library(gtools)
  library(GenomicRanges)
  library(IRanges)
  library(S4Vectors)
  library(wiggleplotr)
  library(Matrix)
  library(data.table)
  library(gridExtra)
})

# set seed
set.seed(123)

# source functions
source(here::here("src", "marvel", "functions.R"))
```

And load in data

```{r load in data}
# load in PSI matrix from script 05
full_psi_matrix <- readRDS("/data/user/efjones/230926_EJ_Setbp1_AlternativeSplicing/data/marvel/full_psi_matrix.Rds")

# Load MARVEL object
setbp1_marvel <- read_rds(here::here(
  "data", "marvel",
  "setbp1_marvel_aligned.rds"
))

# Retrieve sample metadata
sample_metadata <- setbp1_marvel$sample.metadata

# Retrieve sj metadata
sj_metadata <- setbp1_marvel$sj.metadata

# Save counts objects for easy accessibility
sj_counts <- setbp1_marvel[["sj.count.matrix"]]
gene_counts <- setbp1_marvel[["gene.count.matrix"]]

# Convert data type
sj_counts <- as(sj_counts, "CsparseMatrix")
gene_counts <- as(gene_counts, "CsparseMatrix")
```

## Determine numbers of SJ detected per gene for each cell type

First, I'll split up the psi matrix by cell type

```{r get cell groups}
# Pull cell types and matching ids
cell_group_list <- sample_metadata %>%
  group_split(cell_type, .keep = TRUE) %>%
  map(~ set_names(.$cell.id, .$cell_type[1]))

# Rename
cell_group_list <- set_names(cell_group_list, c(
  "Astrocytes", "Excitatory Neurons",
  "Inhibitory Neurons", "Microglia", "OPCs",
  "Oligodendrocytes", "Vascular Cells"
))

# Pull mutant vs wildtype and matching ids
mutant_list <- sample_metadata %>%
  group_split(seq_folder, .keep = TRUE) %>%
  map(~ set_names(.$cell.id, .$seq_folder[[1]]))

# Rename
mutant_list <- set_names(mutant_list, c(
  "Mutant", "Wildtype"
))
```

Now split all matrices by cell type

```{r split matrices by cell type}
astrocytes_matrices <- subset_cell_type_matrices(cell_type = "Astrocytes")

excitatory_matrices <- subset_cell_type_matrices(
  cell_type = "Excitatory Neurons"
)

inhibitory_matrices <- subset_cell_type_matrices(
  cell_type = "Inhibitory Neurons"
)

microglia_matrices <- subset_cell_type_matrices(cell_type = "Microglia")

opcs_matrices <- subset_cell_type_matrices(cell_type = "OPCs")

oligodendrocyte_matrices <- subset_cell_type_matrices(
  cell_type = "Oligodendrocytes"
)

vascular_matrices <- subset_cell_type_matrices(cell_type = "Vascular Cells")
```


Now, we can make a dataframe with the total number of rows divided by number of cells

```{r get how many sjs per cell type}
sj_per_cell_type <- data.frame(
  "cell_type" = c(
    "Astrocytes", "Excitatory Neurons",
    "Inhibitory Neurons", "Microglia", "OPCs",
    "Oligodendrocytes", "Vascular Cells"
  ),
  "sj_number" = c(
    nrow(astrocytes_matrices[[2]]),
    nrow(excitatory_matrices[[2]]),
    nrow(inhibitory_matrices[[2]]),
    nrow(microglia_matrices[[2]]),
    nrow(oligodendrocyte_matrices[[2]]),
    nrow(opcs_matrices[[2]]),
    nrow(vascular_matrices[[2]])
  ),
  "sjs_per_gene" = c(
    nrow(astrocytes_matrices[[2]]) /
  nrow(astrocytes_matrices[[1]]),
nrow(excitatory_matrices[[2]]) /
  nrow(excitatory_matrices[[1]]),
nrow(inhibitory_matrices[[2]]) /
  nrow(inhibitory_matrices[[1]]),
nrow(microglia_matrices[[2]]) /
  nrow(microglia_matrices[[1]]),
nrow(oligodendrocyte_matrices[[2]]) /
  nrow(oligodendrocyte_matrices[[1]]),
nrow(opcs_matrices[[2]]) /
  nrow(opcs_matrices[[1]]),
nrow(vascular_matrices[[2]]) /
  nrow(vascular_matrices[[1]])
  )
)
```


```{r visualize splice junctions per cell type}

ggplot(sj_per_cell_type, aes(x = cell_type, y = sjs_per_gene, fill = cell_type)) +
  geom_bar(stat = "identity") +
  theme(legend.position = "none")

```

## Aggregate metrics by mutant and wildtype

I made a function called subset_mutant_matrices. I can use this to split the sj and gene count matrices

```{r split into mutant and wildtype}

astrocytes_mutants <- subset_mutant_matrices(astrocytes_matrices)

excitatory_mutants <- subset_mutant_matrices(excitatory_matrices)

inhibitory_mutants <- subset_mutant_matrices(inhibitory_matrices)

microglia_mutants <- subset_mutant_matrices(microglia_matrices)

oligodendrocyte_mutants <- subset_mutant_matrices(oligodendrocyte_matrices)

opcs_mutants <- subset_mutant_matrices(opcs_matrices)

vascular_mutants <- subset_mutant_matrices(vascular_matrices)

```

Now, I can amke a similar dataframe and plot from that.

```{r make aggregated df for mutants}

sj_per_condition <- data.frame(
  "cell_type" = rep(c(
    "Astrocytes", "Excitatory Neurons",
    "Inhibitory Neurons", "Microglia", "OPCs",
    "Oligodendrocytes", "Vascular Cells"
  ), 2),
  
  "condition" = c(rep("Mutant", 7), rep("Wildtype", 7)),
  
  "sj_number" = c(
    nrow(astrocytes_mutants$Mutant[[2]]),
    nrow(excitatory_mutants$Mutant[[2]]),
    nrow(inhibitory_mutants$Mutant[[2]]),
    nrow(microglia_mutants$Mutant[[2]]),
    nrow(oligodendrocyte_mutants$Mutant[[2]]),
    nrow(opcs_mutants$Mutant[[2]]),
    nrow(vascular_mutants$Mutant[[2]]),
    nrow(astrocytes_mutants$Wildtype[[2]]),
    nrow(excitatory_mutants$Wildtype[[2]]),
    nrow(inhibitory_mutants$Wildtype[[2]]),
    nrow(microglia_mutants$Wildtype[[2]]),
    nrow(oligodendrocyte_mutants$Wildtype[[2]]),
    nrow(opcs_mutants$Wildtype[[2]]),
    nrow(vascular_mutants$Wildtype[[2]])
  ),
  
  "sjs_per_gene" = c(
    nrow(astrocytes_mutants$Mutant[[2]]) /
      nrow(astrocytes_mutants$Mutant[[1]]),
    nrow(excitatory_mutants$Mutant[[2]]) /
      nrow(excitatory_mutants$Mutant[[1]]),
    nrow(inhibitory_mutants$Mutant[[2]]) /
      nrow(inhibitory_mutants$Mutant[[1]]),
    nrow(microglia_mutants$Mutant[[2]]) /
      nrow(microglia_mutants$Mutant[[1]]),
    nrow(oligodendrocyte_mutants$Mutant[[2]]) /
      nrow(oligodendrocyte_mutants$Mutant[[1]]),
    nrow(opcs_mutants$Mutant[[2]]) /
      nrow(opcs_mutants$Mutant[[1]]),
    nrow(vascular_mutants$Mutant[[2]]) /
      nrow(vascular_mutants$Mutant[[1]]),
    nrow(astrocytes_mutants$Wildtype[[2]]) /
      nrow(astrocytes_mutants$Wildtype[[1]]),
    nrow(excitatory_mutants$Wildtype[[2]]) /
      nrow(excitatory_mutants$Wildtype[[1]]),
    nrow(inhibitory_mutants$Wildtype[[2]]) /
      nrow(inhibitory_mutants$Wildtype[[1]]),
    nrow(microglia_mutants$Wildtype[[2]]) /
      nrow(microglia_mutants$Wildtype[[1]]),
    nrow(oligodendrocyte_mutants$Wildtype[[2]]) /
      nrow(oligodendrocyte_mutants$Wildtype[[1]]),
    nrow(opcs_mutants$Wildtype[[2]]) /
      nrow(opcs_mutants$Wildtype[[1]]),
    nrow(vascular_mutants$Wildtype[[2]]) /
      nrow(vascular_mutants$Wildtype[[1]])
  ),
  
  "cell_count" = c(
  ncol(astrocytes_mutants$Mutant[[2]]),
  ncol(excitatory_mutants$Mutant[[2]]),
  ncol(inhibitory_mutants$Mutant[[2]]),
  ncol(microglia_mutants$Mutant[[2]]),
  ncol(oligodendrocyte_mutants$Mutant[[2]]),
  ncol(opcs_mutants$Mutant[[2]]),
  ncol(vascular_mutants$Mutant[[2]]),
  ncol(astrocytes_mutants$Wildtype[[2]]),
  ncol(excitatory_mutants$Wildtype[[2]]),
  ncol(inhibitory_mutants$Wildtype[[2]]),
  ncol(microglia_mutants$Wildtype[[2]]),
  ncol(oligodendrocyte_mutants$Wildtype[[2]]),
  ncol(opcs_mutants$Wildtype[[2]]),
  ncol(vascular_mutants$Wildtype[[2]])
)
)

```


```{r visualize splice junctions per cell type}
# plot
ggplot(sj_per_condition, aes(x = cell_type, y = sjs_per_gene, fill = condition)) +
  geom_bar(stat = "identity", position = position_dodge())

```

I notice there are more sjs per gene for all wts compared to controls, is this true for all cell counts?

```{r look at cell counts}
ggplot(sj_per_condition, aes(x = cell_type, y = cell_count, fill = condition)) +
  geom_bar(stat = "identity", position = position_dodge())
```

Yes, there are more cells so this score is imperfect and not something I want to draw major conclusions from.

Now, what if we calculate this "splicing complexity score" for every single cell? Also, we can count how many splice junctions are detected per gene without averaging. Let's do that first.

## Count splice junctions for each gene

```{r count splice junctions}
# Get all expressed gene names
all_expressed_genes <- unique(c(names(get_sjs_per_gene(astrocytes_matrices)),
                     names(get_sjs_per_gene(excitatory_matrices)),
                     names(get_sjs_per_gene(inhibitory_matrices)),
                     names(get_sjs_per_gene(microglia_matrices)),
                     names(get_sjs_per_gene(oligodendrocyte_matrices)),
                     names(get_sjs_per_gene(opcs_matrices)),
                     names(get_sjs_per_gene(vascular_matrices))))

# Make NA matrix, with 7 columns for cell types
sj_per_gene <- matrix(NA, nrow = length(all_expressed_genes), ncol = 7)
# Add rownames
rownames(sj_per_gene) <- sort(all_expressed_genes)

# Make a list of all matrices
matrices_list <- ls(pattern = "_matrices")

# Initialize column
column <- 0

# Add in each table - these numbers are to exclude the functions I called into
# the list. You could procedurally remove things of the class function but I am lazy
for(i in matrices_list[c(1:6, 9)]) {
  column <- column + 1
  table <- get_sjs_per_gene(get(i))
  indices <- match(rownames(sj_per_gene), names(table))
  sj_per_gene[, column] <- ifelse(!is.na(indices), table[indices], 0)
}

# Add colnames
colnames(sj_per_gene) <- substr(matrices_list[c(1:6, 9)], 1, nchar(matrices_list[c(1:6, 9)]) - 9)

```

I think it would be neat to show this as a pca.

```{r do pca on sj counts}
# Transform matrix
sj_per_gene_t <- t(sj_per_gene)

sj_per_gene_t <- remove_0_variance(as.data.frame(sj_per_gene_t))

pca <- prcomp(sj_per_gene_t, scale = TRUE)

fviz_eig(pca)

fviz_pca_ind(pca,
             col.ind = "cos2", # Color by the quality of representation
             gradient.cols = c("#00AFBB", "#E7B800", "#FC4E07"),
             repel = TRUE, # Avoid text overlapping
             )

fviz_pca_var(pca,
             col.var = "contrib",
             gradient.cols = c("#00AFBB", "#E7B800", "#FC4E07"),
             repel = TRUE,
             select.var = list(contrib = 10)
             )


```

I think this is a good direction, but I need to do for each sample and for each cell type (mutant and wt). I'm unsure the best way to do this, I could split out 7 by 6 samples into 42 groups, or just do in aggregate first?

```{r do same thing for mutant and wildtypes}
# Make NA matrix, with 14 columns (one for each aggregation)
sj_per_gene_mut <- matrix(NA, nrow = length(all_expressed_genes), ncol = 14)
# Add rownames
rownames(sj_per_gene_mut) <- sort(all_expressed_genes)

# Make a list of all mutant matrices
mutants_list <- ls(pattern = "_mutants")

# Initialize column
column1 <- 0

# Add in each table with for loop
for(i in (mutants_list)) {
  # get object
  object <- get(i)
  # mutants
  column1 <- column1 + 1
  table <- get_sjs_per_gene(object[["Mutant"]])
  indices <- match(rownames(sj_per_gene_mut), names(table))
  sj_per_gene_mut[, column1] <- ifelse(!is.na(indices), table[indices], 0)
  
  # wildtypes
  column2 <- column1 + 7
  table <- get_sjs_per_gene(object[["Wildtype"]])
  indices <- match(rownames(sj_per_gene_mut), names(table))
  sj_per_gene_mut[, column2] <- ifelse(!is.na(indices), table[indices], 0)
}

# Add colnames
colnames(sj_per_gene_mut) <- c(paste0(substr(mutants_list, 1, nchar(mutants_list) - 8), "_mutants"), paste0(substr(mutants_list, 1, nchar(mutants_list) - 8), "_wildtype"))

```

Now we can do a pca on these groups

```{r now do pca!!!}
# Transform matrix
sj_per_gene_mut_t <- t(sj_per_gene_mut)

sj_per_gene_mut_t <- remove_0_variance(as.data.frame(sj_per_gene_mut_t))

pca_mut <- prcomp(sj_per_gene_mut_t, scale = TRUE)

fviz_eig(pca_mut)

fviz_pca_ind(pca_mut,
             col.ind = "cos2", # Color by the quality of representation
             gradient.cols = c("#00AFBB", "#E7B800", "#FC4E07"),
             repel = TRUE, # Avoid text overlapping
             )

fviz_pca_var(pca_mut,
             col.var = "contrib",
             gradient.cols = c("#00AFBB", "#E7B800", "#FC4E07"),
             repel = TRUE,
             select.var = list(contrib = 10)
             )


```

Not sure how to interpret that very much, but now I can do back to doing what I was aiming to do this morning and got sidetracked from.


#### Style

```{r tidy script}
style_file("05_join_psi_matrix.Rmd")

lint("05_join_psi_matrix.Rmd",
  linters = linters_with_defaults(
    object_length_linter = NULL,
    object_name_linter = NULL,
    object_usage_linter = NULL
  )
)
```

#### Software versions

My software versions will be commented below.

```{r versions}
sessionInfo()
```

